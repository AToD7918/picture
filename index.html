<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=yes">
<title>Photos</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#000;overflow:hidden}
  .viewer{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
  .img-container{width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative;transform-origin:center center}
  img{max-width:100%;max-height:100%;object-fit:contain;user-select:none;touch-action:none}
</style>
</head>
<body>

<div class="viewer">
  <div class="img-container" id="container">
    <img id="big" alt="">
  </div>
</div>

<script>
(async () => {
  sleep(100);
  location.reload(true);
  
  const ts = Date.now();
  const manifest = await fetch('manifest.json?_=' + ts).then(r=>r.json());
  const images = manifest.images || [];
  const params = new URLSearchParams(location.search);
  let idx = Math.max(0, images.findIndex(x => x.id === params.get('id')));
  if (idx === -1) idx = 0;

  const big = document.getElementById('big');
  const container = document.getElementById('container');

  // 줌/팬 상태
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  let initialDistance = 0;
  let initialScale = 1;
  let initialTranslateX = 0;
  let initialTranslateY = 0;
  let pinchCenterX = 0;
  let pinchCenterY = 0;
  let initialX = 0;
  let initialY = 0;

  function updateTransform() {
    container.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  function resetZoom() {
    scale = 1;
    translateX = 0;
    translateY = 0;
    updateTransform();
  }

  // 특정 점을 중심으로 줌
  function zoomToPoint(clientX, clientY, newScale) {
    const rect = container.getBoundingClientRect();
    const offsetX = clientX - rect.left - rect.width / 2;
    const offsetY = clientY - rect.top - rect.height / 2;
    
    // 현재 scale에서의 offset을 계산
    const oldOffsetX = (offsetX - translateX) / scale;
    const oldOffsetY = (offsetY - translateY) / scale;
    
    // 새로운 scale로 변환
    translateX = offsetX - oldOffsetX * newScale;
    translateY = offsetY - oldOffsetY * newScale;
    scale = newScale;
  }

  function render(i){
    if (!images[i]) return;
    big.src = images[i].src + '?_=' + ts;
    big.alt = images[i].alt || '';
    history.replaceState(null,'', images[i].id ? `?id=${encodeURIComponent(images[i].id)}` : location.pathname);
    resetZoom();
  }

  // 두 터치 포인트 사이의 거리 계산
  function getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // 두 터치 포인트의 중심점 계산
  function getCenter(touches) {
    return {
      x: (touches[0].clientX + touches[1].clientX) / 2,
      y: (touches[0].clientY + touches[1].clientY) / 2
    };
  }

  // 핀치 줌 & 팬
  let isPinching = false;
  let isPanning = false;
  let lastTouchTime = 0;

  container.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      // 핀치 줌 시작
      e.preventDefault();
      isPinching = true;
      initialDistance = getDistance(e.touches);
      initialScale = scale;
      initialTranslateX = translateX;
      initialTranslateY = translateY;
      const center = getCenter(e.touches);
      pinchCenterX = center.x;
      pinchCenterY = center.y;
    } else if (e.touches.length === 1 && scale > 1) {
      // 줌 상태에서 팬 시작
      e.preventDefault();
      isPanning = true;
      initialX = e.touches[0].clientX - translateX;
      initialY = e.touches[0].clientY - translateY;
    } else if (e.touches.length === 1) {
      // 스와이프를 위한 시작점 저장
      touchStartX = e.touches[0].clientX;
      lastTouchTime = Date.now();
    }
  }, {passive: false});

  container.addEventListener('touchmove', (e) => {
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const distance = getDistance(e.touches);
      const newScale = Math.max(1, Math.min(5, initialScale * (distance / initialDistance)));
      
      // 핀치 시작 시의 중심점을 기준으로 줌 (고정된 중심점 사용)
      const rect = container.getBoundingClientRect();
      const offsetX = pinchCenterX - rect.left - rect.width / 2;
      const offsetY = pinchCenterY - rect.top - rect.height / 2;
      
      const oldOffsetX = (offsetX - initialTranslateX) / initialScale;
      const oldOffsetY = (offsetY - initialTranslateY) / initialScale;
      
      translateX = offsetX - oldOffsetX * newScale;
      translateY = offsetY - oldOffsetY * newScale;
      scale = newScale;
      
      updateTransform();
    } else if (isPanning && e.touches.length === 1 && scale > 1) {
      e.preventDefault();
      translateX = e.touches[0].clientX - initialX;
      translateY = e.touches[0].clientY - initialY;
      updateTransform();
    }
  }, {passive: false});

  container.addEventListener('touchend', (e) => {
    if (isPinching && e.touches.length < 2) {
      // 핀치 종료 - 줌 상태 유지
      isPinching = false;
      // scale이 1에 매우 가까우면 리셋
      if (scale < 1.05) {
        resetZoom();
      }
    } else if (isPanning && e.touches.length === 0) {
      // 팬 종료
      isPanning = false;
    } else if (!isPinching && !isPanning && e.touches.length === 0 && scale === 1) {
      // 스와이프 처리 (줌/팬 상태가 아니고 scale이 1일 때만)
      const touchDuration = Date.now() - lastTouchTime;
      if (touchDuration < 300) {
        touchEndX = e.changedTouches[0].clientX;
        const diff = touchStartX - touchEndX;
        
        if (Math.abs(diff) > 50) {
          if (diff > 0) {
            idx = (idx + 1) % images.length;
          } else {
            idx = (idx - 1 + images.length) % images.length;
          }
          render(idx);
        }
      }
    }
  }, {passive: false});

  // 더블탭으로 줌 토글
  let lastTap = 0;
  let lastTapX = 0;
  let lastTapY = 0;
  
  container.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300 && e.touches.length === 0) {
      e.preventDefault();
      if (scale === 1) {
        // 더블탭 위치를 중심으로 줌인
        const touch = e.changedTouches[0];
        zoomToPoint(touch.clientX, touch.clientY, 2.5);
        updateTransform();
      } else {
        resetZoom();
      }
    }
    lastTap = now;
    if (e.changedTouches.length > 0) {
      lastTapX = e.changedTouches[0].clientX;
      lastTapY = e.changedTouches[0].clientY;
    }
  });

  // 스와이프 (기존 코드 제거됨 - 위의 touchend에 통합)
  let touchStartX = 0;
  let touchEndX = 0;
  
  // 제거: document.addEventListener('touchstart', ...)
  // 제거: document.addEventListener('touchend', ...)

  // 키보드 화살표
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') {
      idx = (idx - 1 + images.length) % images.length;
      render(idx);
    } else if (e.key === 'ArrowRight') {
      idx = (idx + 1) % images.length;
      render(idx);
    }
  });

  render(idx);
})();
</script>
</body>
</html>