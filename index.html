<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=yes">
<title>Photos</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#000;overflow:hidden}
  .viewer{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
  .img-container{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    transform-origin:center center;
    touch-action:none; /* 브라우저 제스처 차단 */
  }
  img{max-width:100%;max-height:100%;object-fit:contain;user-select:none;touch-action:none}
</style>
</head>
<body>

<div class="viewer">
  <div class="img-container" id="container">
    <img id="big" alt="">
  </div>
</div>

<script>
(async () => {
  const ts = Date.now();
  const manifest = await fetch('manifest.json?_=' + ts).then(r=>r.json());
  const images = manifest.images || [];
  const params = new URLSearchParams(location.search);
  let idx = Math.max(0, images.findIndex(x => x.id === params.get('id')));
  if (idx === -1) idx = 0;

  const big = document.getElementById('big');
  const container = document.getElementById('container');

  // 줌/팬 상태
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  let initialDistance = 0;
  let initialScale = 1;
  let initialTranslateX = 0;
  let initialTranslateY = 0;
  let pinchCenterX = 0;
  let pinchCenterY = 0;
  let initialX = 0;
  let initialY = 0;

  function updateTransform() {
    container.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  // 이미지 경계 제한
  function constrainTranslate() {
    if (scale <= 1) {
      translateX = 0;
      translateY = 0;
      return;
    }

    const imgRect = big.getBoundingClientRect();
    const viewerRect = container.parentElement.getBoundingClientRect();

    // 이미지의 실제 크기 (확대된 상태)
    const imgWidth = imgRect.width;
    const imgHeight = imgRect.height;

    // 뷰포트 크기
    const viewWidth = viewerRect.width;
    const viewHeight = viewerRect.height;

    // 이미지가 뷰포트보다 클 때만 제한
    if (imgWidth > viewWidth) {
      const maxX = (imgWidth - viewWidth) / 2;
      translateX = Math.max(-maxX, Math.min(maxX, translateX));
    } else {
      translateX = 0;
    }

    if (imgHeight > viewHeight) {
      const maxY = (imgHeight - viewHeight) / 2;
      translateY = Math.max(-maxY, Math.min(maxY, translateY));
    } else {
      translateY = 0;
    }
  }

  function updateTransformConstrained() {
    constrainTranslate();
    updateTransform();
  }

  function resetZoom() {
    scale = 1;
    translateX = 0;
    translateY = 0;
    updateTransform();
  }

  // 특정 점을 중심으로 줌
  function zoomToPoint(clientX, clientY, newScale) {
    const rect = container.getBoundingClientRect();
    const offsetX = clientX - rect.left - rect.width / 2;
    const offsetY = clientY - rect.top - rect.height / 2;

    const oldOffsetX = (offsetX - translateX) / scale;
    const oldOffsetY = (offsetY - translateY) / scale;

    translateX = offsetX - oldOffsetX * newScale;
    translateY = offsetY - oldOffsetY * newScale;
    scale = newScale;
  }

  function render(i){
    if (!images[i]) return;
    big.src = images[i].src + '?_=' + ts;
    big.alt = images[i].alt || '';
    history.replaceState(null,'', images[i].id ? `?id=${encodeURIComponent(images[i].id)}` : location.pathname);
    resetZoom();
  }

  function getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function getCenter(touches) {
    return {
      x: (touches[0].clientX + touches[1].clientX) / 2,
      y: (touches[0].clientY + touches[1].clientY) / 2
    };
  }

  let isPinching = false;
  let isPanning = false;
  let lastTouchTime = 0;
  let justPinched = false;
  let justPinchTimer = null;

  container.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      justPinched = false;
      if (justPinchTimer) { clearTimeout(justPinchTimer); justPinchTimer = null; }
      isPinching = true;
      initialDistance = getDistance(e.touches);
      initialScale = scale;
      initialTranslateX = translateX;
      initialTranslateY = translateY;
      const center = getCenter(e.touches);
      pinchCenterX = center.x;
      pinchCenterY = center.y;
    } else if (e.touches.length === 1 && scale > 1) {
      e.preventDefault();
      isPanning = true;
      initialX = e.touches[0].clientX - translateX;
      initialY = e.touches[0].clientY - translateY;
    } else if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      lastTouchTime = Date.now();
    }
  }, {passive: false});

  container.addEventListener('touchmove', (e) => {
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const distance = getDistance(e.touches);
      const newScale = Math.max(1, Math.min(5, initialScale * (distance / initialDistance)));

      const rect = container.getBoundingClientRect();
      const offsetX = pinchCenterX - rect.left - rect.width / 2;
      const offsetY = pinchCenterY - rect.top - rect.height / 2;

      const oldOffsetX = (offsetX - initialTranslateX) / initialScale;
      const oldOffsetY = (offsetY - initialTranslateY) / initialScale;

      translateX = offsetX - oldOffsetX * newScale;
      translateY = offsetY - oldOffsetY * newScale;
      scale = newScale;

      updateTransformConstrained();
    } else if (isPanning && e.touches.length === 1 && scale > 1) {
      e.preventDefault();
      translateX = e.touches[0].clientX - initialX;
      translateY = e.touches[0].clientY - initialY;
      updateTransformConstrained();
    }
  }, {passive: false});

  let touchStartX = 0;
  let touchEndX = 0;
  let lastTap = 0;

  container.addEventListener('touchend', (e) => {
    const now = Date.now();
    const timeSinceLastTap = now - lastTap;

    // 더블탭 감지
    if (!justPinched && timeSinceLastTap < 300 && timeSinceLastTap > 0 && e.touches.length === 0 && !isPinching && !isPanning) {
      e.preventDefault();
      if (scale === 1) {
        const touch = e.changedTouches[0];
        zoomToPoint(touch.clientX, touch.clientY, 2.5);
        updateTransformConstrained();
      } else {
        resetZoom();
      }
      lastTap = 0;
      return;
    }

    // 핀치 종료
    if (isPinching && e.touches.length < 2) {
      isPinching = false;
      justPinched = true;
      if (justPinchTimer) clearTimeout(justPinchTimer);
      justPinchTimer = setTimeout(()=>{ justPinched = false; justPinchTimer = null; }, 400);
      lastTap = 0;
      return;
    }

    // 팬 종료
    if (isPanning && e.touches.length === 0) {
      isPanning = false;
      lastTap = now;
      return;
    }

    // 스와이프 처리
    if (!isPinching && !isPanning && e.touches.length === 0 && scale === 1) {
      const touchDuration = Date.now() - lastTouchTime;
      if (touchDuration < 300) {
        touchEndX = e.changedTouches[0].clientX;
        const diff = touchStartX - touchEndX;
        if (Math.abs(diff) > 50) {
          if (diff > 0) {
            idx = (idx + 1) % images.length;
          } else {
            idx = (idx - 1 + images.length) % images.length;
          }
          render(idx);
          lastTap = 0;
          return;
        }
      }
    }

    lastTap = now;
  }, {passive: false});

  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') {
      idx = (idx - 1 + images.length) % images.length;
      render(idx);
    } else if (e.key === 'ArrowRight') {
      idx = (idx + 1) % images.length;
      render(idx);
    }
  });

  render(idx);
})();
</script>
</body>
</html>
